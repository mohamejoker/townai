// TODO: Consider more secure API key storage for production (e.g., environment variables for backend functions or a secrets manager).
interface Provider {
  id: string; // UUID
  name: string;
  api_url: string;
  api_key: string; // Encrypted in the database
  is_active: boolean;
  logo_url?: string;
  settings?: Record<string, any>; // JSONB for provider-specific settings
  description?: string;
  reliability?: number; // Percentage
  speed?: 'fast' | 'medium' | 'slow';
  supportedPlatforms?: string[]; // Array of strings
  lastSync?: Date; // Keep this for local state if needed, or rely on updated_at
  added_at: string; // Timestamptz
  updated_at: string; // Timestamptz
}

// Aligned with provider_services table schema
interface ProviderServiceItem {
  id?: string; // UUID, generated by DB
  provider_id: string; // Foreign key to providers table
  external_service_id: string; // ID from the external provider
  name: string;
  type?: 'followers' | 'likes' | 'views' | 'comments' | 'shares' | 'custom'; // Broader type
  platform?: 'instagram' | 'tiktok' | 'youtube' | 'twitter' | 'snapchat' | 'facebook' | 'web' | 'other'; // Broader platform
  category?: string; // Category from provider
  rate?: number; // Cost per 1000 or per item
  min_order?: number;
  max_order?: number;
  description?: string;
  is_active?: boolean; // Service status from provider
  quality?: 'high' | 'medium' | 'low' | 'premium' | 'standard';
  refill_enabled?: boolean;
  cancel_enabled?: boolean;
  average_time?: string; // e.g., "1-2 hours", "24-48 hours"
  features?: string[]; // JSONB in DB
  custom_fields?: Record<string, any>; // JSONB for additional fields
  synced_at?: string; // Timestamptz
  updated_at?: string; // Timestamptz
}


import { smmPartyProvider, type SMMPartyService } from './smmPartyProvider';
import { supabase } from '../../integrations/supabase/client'; // Import Supabase client

class ProviderService {
  // private services: ProviderServiceItem[] = []; // Removed in-memory service cache

  async getProviders(): Promise<Provider[]> {
    const { data, error } = await supabase.from('providers').select('*');
    if (error) {
      console.error('Error fetching providers:', error);
      throw error;
    }
    return data as Provider[];
  }

  async getProvider(id: string): Promise<Provider | null> {
    const { data, error } = await supabase.from('providers').select('*').eq('id', id).single();
    if (error) {
      if (error.code === 'PGRST116') { // PostgREST error code for "Not Found"
        return null;
      }
      console.error(`Error fetching provider ${id}:`, error);
      throw error;
    }
    return data as Provider;
  }

  async addProvider(providerData: Omit<Provider, 'id' | 'added_at' | 'updated_at' | 'lastSync'>): Promise<Provider> {
    // Ensure api_key is included if your form/data source provides it directly
    // For Supabase, 'added_at' and 'updated_at' are typically handled by DB triggers or default values
    const { data, error } = await supabase
      .from('providers')
      .insert([providerData]) // Supabase expects an array for insert
      .select()
      .single(); // Return the newly created row

    if (error) {
      console.error('Error adding provider:', error);
      throw error;
    }
    return data as Provider;
  }

  async updateProvider(id: string, updates: Partial<Omit<Provider, 'id' | 'added_at' | 'updated_at'>>): Promise<Provider | null> {
    const { data, error } = await supabase
      .from('providers')
      .update(updates)
      .eq('id', id)
      .select()
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null; // Not found
      console.error(`Error updating provider ${id}:`, error);
      throw error;
    }
    return data as Provider;
  }

  async deleteProvider(id: string): Promise<boolean> {
    const { error } = await supabase.from('providers').delete().eq('id', id);
    if (error) {
      console.error(`Error deleting provider ${id}:`, error);
      // Optionally, you could check for specific error codes if needed
      return false;
    }
    // When a provider is deleted, its services should also be cleaned up from provider_services.
    // This can be handled by a database cascade delete constraint or explicitly here.
    // For now, assuming cascade or manual cleanup elsewhere if necessary.
    // this.services = this.services.filter(s => s.providerId !== id);
    return true;
  }

  async syncProviderServices(providerId: string): Promise<ProviderServiceItem[]> {
    const provider = await this.getProvider(providerId);
    if (!provider || !provider.is_active || !provider.api_url || !provider.api_key) {
      const message = `Provider ${providerId} not found, inactive, or missing API configuration.`;
      await this.logSyncAttempt(providerId, 'failure', message, { error_details: message });
      throw new Error(message);
    }

    let fetchedServices: SMMPartyService[] = []; // Assuming SMMPartyService is the raw type from provider
    let syncStatus: 'success' | 'failure' = 'failure';
    let syncMessage: string = '';
    let details: Record<string, any> = {};
    let transformedServices: ProviderServiceItem[] = [];

    try {
      if (provider.name === 'SMM Party') { // Example for SMM Party
        const tempSmmPartyProvider = new smmPartyProvider(provider.api_key, provider.api_url);
        fetchedServices = await tempSmmPartyProvider.getServices();
      } else {
        // TODO: Implement logic for other provider types if any
        syncMessage = `Provider type '${provider.name}' not supported for automated sync.`;
        await this.logSyncAttempt(providerId, 'failure', syncMessage, { provider_name: provider.name });
        throw new Error(syncMessage);
      }

      // Delete existing services for this provider
      const { error: deleteError } = await supabase
        .from('provider_services')
        .delete()
        .eq('provider_id', providerId);

      if (deleteError) {
        syncMessage = `Failed to delete existing services for provider ${providerId}.`;
        details = { error_details: deleteError.message };
        throw new Error(syncMessage);
      }

      const now = new Date().toISOString();
      transformedServices = fetchedServices.map((service: SMMPartyService): ProviderServiceItem => ({
        provider_id: providerId,
        external_service_id: service.service.toString(), // Ensure it's a string
        name: service.name,
        type: this.mapServiceType(service.type),
        platform: this.mapPlatform(service.category), // Assuming category maps to platform
        category: service.category,
        rate: parseFloat(service.rate),
        min_order: parseInt(service.min),
        max_order: parseInt(service.max),
        description: service.name, // Or more detailed if available
        is_active: true, // Assuming services from provider are active; adjust if provider gives status
        quality: 'standard', // Default or map from provider data
        refill_enabled: service.refill,
        cancel_enabled: service.cancel,
        average_time: service.dripfeed ? 'N/A (Dripfeed)' : '1-24 hours', // Example, adjust as needed
        synced_at: now,
        // 'updated_at' will be set by DB
      }));

      if (transformedServices.length > 0) {
        const { error: insertError } = await supabase
          .from('provider_services')
          .insert(transformedServices);

        if (insertError) {
          syncMessage = `Failed to insert new services for provider ${providerId}.`;
          details = { error_details: insertError.message, services_attempted: transformedServices.length };
          throw new Error(syncMessage);
        }
      }

      syncStatus = 'success';
      syncMessage = `Successfully synced ${transformedServices.length} services for provider ${providerId}.`;
      details = { services_synced: transformedServices.length };
      await this.updateProvider(providerId, { lastSync: new Date() }); // Update provider's lastSync

    } catch (error: any) {
      syncStatus = 'failure';
      // If syncMessage wasn't set by a specific step, use a generic one
      if (!syncMessage) {
        syncMessage = `Error syncing services for provider ${providerId}: ${error.message}`;
      }
      // Ensure details are set if not already
      if (Object.keys(details).length === 0) {
        details = { error_details: error.message, raw_error: error };
      }
      console.error(syncMessage, details);
    } finally {
      await this.logSyncAttempt(providerId, syncStatus, syncMessage, details);
    }

    if (syncStatus === 'failure') {
      // Re-throw the error so the caller knows the sync failed overall
      throw new Error(syncMessage);
    }
    return transformedServices; // Return the services that were successfully processed and intended for insertion
  }

  private async logSyncAttempt(provider_id: string, status: 'success' | 'failure', message: string, details?: Record<string, any>) {
    const { error: logError } = await supabase.from('provider_sync_logs').insert({
      provider_id,
      status,
      message,
      details,
    });
    if (logError) {
      console.error(`Failed to log sync attempt for provider ${provider_id}:`, logError);
    }
  }

  private mapServiceType(type: string): ProviderServiceItem['type'] {
    const lowerType = type.toLowerCase();
    if (lowerType.includes('follow')) return 'followers';
    if (lowerType.includes('like')) return 'likes';
    if (lowerType.includes('view')) return 'views';
    if (lowerType.includes('comment')) return 'comments';
    if (lowerType.includes('share')) return 'shares';
    // Add more mappings as needed or return a default
    return 'custom'; // Default for unmapped types
  }

  private mapPlatform(category: string): ProviderServiceItem['platform'] {
    const lowerType = type.toLowerCase();
    if (lowerType.includes('follow')) return 'followers';
    if (lowerType.includes('like')) return 'likes';
    if (lowerType.includes('view')) return 'views';
    if (lowerType.includes('comment')) return 'comments';
    if (lowerType.includes('share')) return 'shares';
    return 'likes'; // افتراضي
  }

  private mapPlatform(category: string): 'instagram' | 'tiktok' | 'youtube' | 'twitter' | 'snapchat' {
    const lowerCategory = category.toLowerCase();
    if (lowerCategory.includes('instagram')) return 'instagram';
    if (lowerCategory.includes('tiktok')) return 'tiktok';
    if (lowerCategory.includes('youtube')) return 'youtube';
    if (lowerCategory.includes('twitter')) return 'twitter';
    if (lowerCategory.includes('snapchat')) return 'snapchat';
    return 'instagram'; // افتراضي
  }

  // Renamed from createOrder to be more specific about its role
  async createActualOrderToProvider(
    linkedProviderServiceId: string, // This is the ID from our provider_services table
    link: string,
    quantity: number
  ): Promise<{ provider_order_id: string; [key: string]: any; }> {
    const { data: providerServiceDetails, error: serviceDetailsError } = await supabase
      .from('provider_services')
      .select('external_service_id, provider_id')
      .eq('id', linkedProviderServiceId)
      .single();

    if (serviceDetailsError || !providerServiceDetails) {
      console.error(`Error fetching provider service details for ID ${linkedProviderServiceId}:`, serviceDetailsError);
      throw new Error(`Provider service with ID ${linkedProviderServiceId} not found or error fetching details.`);
    }

    const { external_service_id, provider_id } = providerServiceDetails;

    const provider = await this.getProvider(provider_id);
    if (!provider || !provider.is_active || !provider.api_key || !provider.api_url) {
      throw new Error(`Provider (ID: ${provider_id}) not found, is not active, or missing API configuration.`);
    }

    if (provider.name === 'SMM Party') { // Example for SMM Party
      const tempSmmPartyProvider = new smmPartyProvider(provider.api_key, provider.api_url);
      try {
        const result = await tempSmmPartyProvider.createOrder(external_service_id, link, quantity);
        // Standardize the response
        if (result && result.order) {
          return { provider_order_id: result.order, ...result };
        } else {
          // If the provider's response format is unexpected
          console.error('Unexpected order placement result from SMM Party:', result);
          throw new Error('Failed to place order with SMM Party due to unexpected response format.');
        }
      } catch (e: any) {
        console.error(`Error placing order with SMM Party for external_service_id ${external_service_id}:`, e);
        // Re-throw or handle as a specific error type
        throw new Error(`Failed to place order with SMM Party: ${e.message || 'Unknown error'}`);
      }
    } else {
      // TODO: Implement order creation logic for other provider types
      console.warn(`Order creation attempt for unhandled provider type: ${provider.name} (ID: ${provider.id})`);
      throw new Error(`Order placement for provider type '${provider.name}' is not implemented.`);
    }
  }

  async getOrderStatus(orderId: string, providerId: string): Promise<any> { // providerId might be redundant if orderId is globally unique and linked to provider
    const provider = await this.getProvider(providerId);
    if (!provider || !provider.is_active || !provider.api_key || !provider.api_url) {
      throw new Error('Provider not found, is not active, or missing API configuration.');
    }

    if (provider.name === 'SMM Party') {
      const tempSmmPartyProvider = new smmPartyProvider(provider.api_key, provider.api_url);
      return await tempSmmPartyProvider.getOrderStatus(orderId);
    } else {
      // Mock or handle other providers
      console.warn(`Order status check for non-SMM Party provider ${provider.id} or missing API details.`);
      return {
        order: orderId,
        status: 'Unknown', // More realistic mock
        error: 'Provider not fully integrated for order status or API details missing.'
      };
    }
  }

  async getProviderBalance(providerId: string): Promise<number> {
    const provider = await this.getProvider(providerId);
    if (!provider || !provider.is_active || !provider.api_key || !provider.api_url) {
      throw new Error('Provider not found, is not active, or missing API configuration.');
    }

    if (provider.name === 'SMM Party') {
      const tempSmmPartyProvider = new smmPartyProvider(provider.api_key, provider.api_url);
      return await tempSmmPartyProvider.getBalance();
    } else {
      console.warn(`Balance check for non-SMM Party provider ${provider.id} or missing API details.`);
      return 0.00;
    }
  }

  async getProviderServices(providerId?: string): Promise<ProviderServiceItem[]> {
    let query = supabase.from('provider_services').select('*');
    if (providerId) {
      query = query.eq('provider_id', providerId);
    }
    const { data, error } = await query;

    if (error) {
      console.error('Error fetching provider services:', error);
      throw error;
    }
    return data as ProviderServiceItem[];
  }

  // Methods for direct manipulation of services in the local cache are removed.
  // Service management is now primarily via syncProviderServices.
  // If manual adjustment of services in the DB is needed,
  // dedicated methods interacting with Supabase could be added here or in a separate admin service.
  //
  // addService(serviceData: Omit<ProviderServiceItem, 'id'>): ProviderServiceItem { ... }
  // updateService(id: string, updates: Partial<ProviderServiceItem>): ProviderServiceItem | null { ... }
  // deleteService(id: string): boolean { ... }
}

export const providerService = new ProviderService();
